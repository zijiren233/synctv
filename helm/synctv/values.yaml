# SyncTV Helm Chart - Production Configuration
# Documentation: https://github.com/synctv-org/synctv

## Global Settings
global:
  imageRegistry: ""
  imagePullSecrets: []
  storageClass: ""

## Name Overrides
nameOverride: ""
fullnameOverride: ""

## ============================================================================
## SyncTV Deployment (Single binary: HTTP + gRPC + RTMP in one process)
## ============================================================================
replicaCount: 3

image:
  registry: docker.io
  repository: synctv/synctv
  tag: "" # defaults to .Chart.AppVersion
  pullPolicy: IfNotPresent

## Headless Service (for inter-node gRPC discovery)
headlessService:
  enabled: true

## Service Configuration
service:
  type: ClusterIP
  annotations: {}
  # Set to LoadBalancer if you need external access to RTMP
  # type: LoadBalancer
  loadBalancerIP: ""
  loadBalancerSourceRanges: []
  sessionAffinity: ""
  nodePorts:
    rtmp: 31935

## Ingress Configuration (for HTTP API access)
ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/proxy-http-version: "1.1"
    nginx.ingress.kubernetes.io/upstream-hash-by: "$remote_addr"
    nginx.ingress.kubernetes.io/proxy-body-size: "500m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
  hosts:
    - host: synctv.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: synctv-tls
      hosts:
        - synctv.example.com
  ## gRPC Ingress (separate Ingress with GRPC backend-protocol annotation)
  grpc:
    enabled: false
    annotations: {}
    hosts:
      - host: grpc.synctv.example.com
        paths:
          - path: /
            pathType: Prefix

## Resource Limits
resources:
  limits:
    cpu: 2000m
    memory: 4Gi
  requests:
    cpu: 500m
    memory: 1Gi

## Autoscaling
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

## Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 2

## Health Checks
startupProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 30  # 5 + 30*5 = 155s max startup time (for migrations)

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health/ready
    port: http
  initialDelaySeconds: 0
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

## Pod Settings
podAnnotations: {}
podLabels: {}

## Graceful Shutdown
terminationGracePeriodSeconds: 60

## Lifecycle Hooks
## preStop hook ensures in-flight requests complete before pod termination.
## The sleep delay allows the endpoints controller to remove the pod from
## service endpoints before the application begins shutting down.
lifecycle:
  preStop:
    exec:
      command: ["sh", "-c", "sleep 5"]

## Node Selection
nodeSelector: {}
tolerations: []

## Affinity rules (overrides podAntiAffinity when set)
## Uncomment and configure to use custom affinity rules:
# affinity:
#   podAntiAffinity:
#     requiredDuringSchedulingIgnoredDuringExecution:
#       - topologyKey: kubernetes.io/hostname

## Pod Anti-Affinity (used when custom affinity is not set)
podAntiAffinity:
  enabled: true

## Topology Spread Constraints (zone-aware scheduling)
topologySpread:
  enabled: true
  maxSkew: 1
  topologyKey: topology.kubernetes.io/zone
  whenUnsatisfiable: DoNotSchedule

## ============================================================================
## Application Configuration
## All field names match the Rust Config struct in synctv-core/src/config.rs
## ============================================================================
config:
  ## ServerConfig
  server:
    host: "0.0.0.0"
    httpPort: 8080
    grpcPort: 50051
    enableReflection: false
    # trustedProxies: ["10.0.0.0/8", "172.16.0.0/12"]
    corsAllowedOrigins:
      - "https://synctv.example.com"

  ## DatabaseConfig (url composed from secrets; these are for connection pool)
  database:
    host: "postgresql.synctv.svc.cluster.local"
    port: 5432
    name: "synctv"
    maxConnections: 20
    minConnections: 5
    connectTimeoutSeconds: 10
    idleTimeoutSeconds: 600

  ## RedisConfig (url composed from secrets; these are for pool settings)
  redis:
    host: "redis-master.synctv.svc.cluster.local"
    port: 6379
    poolSize: 10
    connectTimeoutSeconds: 5
    keyPrefix: "synctv:"

  ## JwtConfig (secret injected via SYNCTV_JWT_SECRET env var)
  jwt:
    accessTokenDurationHours: 1
    refreshTokenDurationDays: 30
    guestTokenDurationHours: 4
    clockSkewLeewaySecs: 60

  ## LoggingConfig
  logging:
    level: "info"
    format: "json"

  ## LivestreamConfig
  livestream:
    rtmpPort: 1935
    maxStreams: 50
    gopCacheSize: 2
    streamTimeoutSeconds: 300
    cleanupCheckIntervalSeconds: 60

  ## ClusterChannelConfig (matches code defaults)
  cluster:
    criticalChannelCapacity: 1000
    publishChannelCapacity: 10000
    ## Discovery mode: "redis" (default) or "k8s_dns" (uses headless service DNS)
    ## In K8s deployments, "k8s_dns" is recommended as it uses native DNS discovery
    discoveryMode: "k8s_dns"

  ## WebRTCConfig
  webrtc:
    mode: "hybrid"  # signaling_only, peer_to_peer, hybrid, sfu
    enableBuiltinStun: true
    stunPort: 3478
    stunHost: "0.0.0.0"
    sfuThreshold: 5
    enableSimulcast: true
    maxSfuRooms: 0
    maxPeersPerSfuRoom: 50
    maxBitratePerPeer: 0
    enableBandwidthEstimation: true

  ## ConnectionLimitsConfig
  connectionLimits:
    maxPerUser: 5
    maxPerRoom: 200
    maxTotal: 10000
    idleTimeoutSeconds: 300
    maxDurationSeconds: 86400

  ## BootstrapConfig
  bootstrap:
    createRootUser: false  # disabled by default in production
    rootUsername: "root"

  ## EmailConfig (only rendered if smtpHost is set)
  email:
    smtpHost: ""
    smtpPort: 587
    fromEmail: ""
    fromName: "SyncTV"
    useTls: true

  ## OAuth2Config
  oauth2:
    redirectScheme: "https"

## ============================================================================
## Secrets (sensitive values injected as env vars with SYNCTV_ prefix)
## ============================================================================
secrets:
  ## Database Credentials (composed into SYNCTV_DATABASE_URL)
  database:
    username: "synctv"
    password: "CHANGE_ME_IN_PRODUCTION"

  ## Redis Password (composed into SYNCTV_REDIS_URL)
  redis:
    password: "CHANGE_ME_IN_PRODUCTION"

  ## JWT Secret (256-bit random string)
  jwt:
    secret: "CHANGE_ME_TO_SECURE_256BIT_RANDOM_STRING"

  ## Cluster gRPC Auth Secret
  cluster:
    grpcSecret: "CHANGE_ME_IN_PRODUCTION"

  ## Email SMTP Credentials (only used when email.smtpHost is set)
  email:
    username: ""
    password: ""

  ## Bootstrap root password (only used when bootstrap.createRootUser is true)
  bootstrap:
    rootPassword: "CHANGE_ME_IN_PRODUCTION"

## ============================================================================
## Additional Settings
## ============================================================================

## Service Account
serviceAccount:
  create: true
  automount: false
  annotations: {}
  name: ""

## Pod Security Context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

## Container Security Context
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true

## Metrics (Prometheus)
## Metrics are served on the main HTTP port at /metrics.
## When metrics.enabled is true, Prometheus scrape annotations are added to the Service.
## For Prometheus Operator environments, enable serviceMonitor instead.
metrics:
  enabled: true
  port: ""    # defaults to config.server.httpPort (8080)
  path: "/metrics"
  serviceMonitor:
    enabled: false
    namespace: ""
    interval: "30s"
    scrapeTimeout: ""
    labels: {}

## Alerting (PrometheusRule)
## Requires metrics.enabled=true and Prometheus Operator CRDs installed
alerting:
  enabled: true
  evaluationInterval: "30s"

## Network Policy
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress

## Extra Environment Variables
extraEnvVars: []
  # - name: AWS_ACCESS_KEY_ID
  #   value: "your-access-key"

## Existing Secret/ConfigMap (if you manage secrets externally)
existingSecret: ""
existingConfigMap: ""

## Image Pull Secrets
imagePullSecrets: []
  # - name: registry-credentials
